/*! For license information please see ace728cf.34c51091.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{100:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return u})),t.d(n,"default",(function(){return m}));var a,o=t(1),r=t(6),i=(t(0),t(109)),p=t(119),s=t(120),l={id:"endpoints",title:"Endpoints",sidebar_label:"Endpoints"},c={id:"endpoints",title:"Endpoints",description:"import Tabs from '@theme/Tabs';",source:"@site/docs/endpoints.md",permalink:"/openhim-mediator-mapping/docs/endpoints",editUrl:"https://github.com/jembi/openhim-mediator-mapping/edit/master/docs/docs/endpoints.md",sidebar_label:"Endpoints",sidebar:"someSidebar",previous:{title:"Setup",permalink:"/openhim-mediator-mapping/docs/setup"},next:{title:"Validation",permalink:"/openhim-mediator-mapping/docs/validation"}},u=[{value:"Configuration files",id:"configuration-files",children:[{value:"1. Meta Data",id:"1-meta-data",children:[]},{value:"2. Input Validation Schema",id:"2-input-validation-schema",children:[]},{value:"3. Input Mapping Schema",id:"3-input-mapping-schema",children:[]},{value:"4. Constants",id:"4-constants",children:[]},{value:"5. Output",id:"5-output",children:[]}]}],b=(a="TabItems",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),Object(i.b)("div",e)}),d={rightToc:u};function m(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"configuration-files"},"Configuration files"),Object(i.b)("p",null,"The configuration files must be stored in a directory in the root of the project named endpoints. This endpoints directory should be further broken down into sub-directories each containing a minimum of four specific files: ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json"),", ",Object(i.b)("inlineCode",{parentName:"p"},"input-mapping.json"),", ",Object(i.b)("inlineCode",{parentName:"p"},"input-validation.json"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"constants.json"),". ",Object(i.b)("inlineCode",{parentName:"p"},"output.json")," is optional at this point. The endpoints directory should be in the following structure:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-txt"}),"\u251c\u2500\u2500 Endpoints\n    \u251c\u2500\u2500 Example Patient Mapping\n        \u251c\u2500\u2500 constants.json (optional)\n        \u251c\u2500\u2500 input-mapping.json\n        \u251c\u2500\u2500 input-validation.json\n        \u251c\u2500\u2500 meta.json\n        \u251c\u2500\u2500 output.json (optional)\n    \u251c\u2500\u2500 Example Observation Mapping\n        \u251c\u2500\u2500 constants.json (optional)\n        \u251c\u2500\u2500 input-mapping.json\n        \u251c\u2500\u2500 input-validation.json\n        \u251c\u2500\u2500 meta.json\n        \u251c\u2500\u2500 output.json (optional)\n    \u251c\u2500\u2500 Example Different Patient Mapping\n        \u251c\u2500\u2500 constants.json (optional)\n        \u251c\u2500\u2500 input-mapping.json\n        \u251c\u2500\u2500 input-validation.json\n        \u251c\u2500\u2500 meta.json\n        \u251c\u2500\u2500 output.json (optional)\n")),Object(i.b)("h3",{id:"1-meta-data"},"1. Meta Data"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json")," file contains the details involved for route setup. The following can be set in the ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json")," file:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Mapping route path"),Object(i.b)("li",{parentName:"ul"},"Expected ",Object(i.b)("strong",{parentName:"li"},"input")," message type"),Object(i.b)("li",{parentName:"ul"},"Desired ",Object(i.b)("strong",{parentName:"li"},"output")," message type"),Object(i.b)("li",{parentName:"ul"},"External requests")),Object(i.b)("h4",{id:"mapping-route-path"},"Mapping Route Path"),Object(i.b)("p",null,"This is the path on which the OpenHIM Mapping Mediator will listen to trigger a specific message mapping transformation. The path is specified in the endpoint pattern property. Url parameters are supported. The URL parameters can be used in the external requests and in the mapping. A request that matches on a pattern like ",Object(i.b)("inlineCode",{parentName:"p"},"/path/:parameter1/:parameter2")," will have the values of these parameters available for use in the external requests and mapping under variable names ",Object(i.b)("inlineCode",{parentName:"p"},"parameter1")," and ",Object(i.b)("inlineCode",{parentName:"p"},"parameter2"),"."),Object(i.b)("h4",{id:"expected-input"},"Expected Input"),Object(i.b)("p",null,"Specify the expected input message type for this specific endpoint to allow the OpenHIM Mapping Mediator to successfully parse the incoming message for processing. Current accepted formats are ",Object(i.b)("inlineCode",{parentName:"p"},"JSON")," and ",Object(i.b)("inlineCode",{parentName:"p"},"XML")),Object(i.b)("h4",{id:"desired-output"},"Desired Output"),Object(i.b)("p",null,"Specify the desired output message type for this specific endpoint to allow the OpenHIM Mapping Mediator to successfully parse the outgoing message. Current accepted formats are ",Object(i.b)("inlineCode",{parentName:"p"},"JSON")," and ",Object(i.b)("inlineCode",{parentName:"p"},"XML")),Object(i.b)("h4",{id:"external-requests"},"External Requests"),Object(i.b)("p",null,"This feature allows for data lookups from external services and the sending of the mapped data to external services. The data to look up and the services where the result of the mapping should be sent are specified in the ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json"),". The data looked up is aggregated with the input data before the validation is done. Below is a sample of a ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json")),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "name": "Test",\n  "endpoint": {\n    "pattern": "/test"\n  },\n  "transformation": {\n    "input": "XML",\n    "output": "JSON"\n  },\n  "requests": {\n    "lookup": [\n      {\n        "id": "1223",\n        "forwardExistingRequestBody": true,\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/encounters/",\n          "params": {\n            "query": {\n              "id": {\n                "path": "payload.id",\n                "prefix": "",\n                "postfix": ""\n              },\n              "address":{\n                "path": "query.location",\n                "prefix": "",\n                "postfix": ""\n              }\n            }\n          }\n        }\n      }\n    ],\n    "response": [\n      {\n        "id": "4433",\n        "config": {\n          "method": "post",\n          "url": "http://localhost:3456/encounters?msn=23",\n          "params": {\n            "query": {\n              "place":{\n                "path": "payload.location[0].code",\n                "prefix": "",\n                "postfix": ""\n              },\n              "code": {\n                "path": "query.unit",\n                "postfix": "",\n                "prefix": ""\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n')),Object(i.b)("p",null,"There are two types of external requests, the ",Object(i.b)("inlineCode",{parentName:"p"},"lookup")," and the ",Object(i.b)("inlineCode",{parentName:"p"},"response"),". Query parameters for the external request can be dynamically populated"),Object(i.b)(p.a,{defaultValue:"lookup",values:[{label:"Lookup",value:"lookup"},{label:"Response",value:"response"},{label:"Query and URL parameters",value:"query"}],mdxType:"Tabs"},Object(i.b)(s.a,{value:"lookup",mdxType:"TabItem"},Object(i.b)("p",null,"  You can fetch data that you want to map. The retrieved data will be aggregated with the input data supplied in the request body. The following shows the aggregation"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'Lookup request:\n\n{\n  "requests": {\n    "lookup": [\n      {\n        "id": "location",\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/location/1",\n          "params": {\n            "query": {\n              "id": {\n                "path": "payload.id"\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n\n\nThe aggregated input that will be validated and then mapped will look like below\n\n\n{\n  lookupRequests: {\n    location: <Result from lookup>\n  },\n  responseBody: {}\n}\n'))),Object(i.b)(s.a,{value:"response",mdxType:"TabItem"},Object(i.b)("p",null,"  The result of the mapping can be orchestrated to external services. The result that will be sent back to the user is the response from the external services. If the mapped data is being orchestrated to multiple services, the response sent back is an aggregation of the responses from the multiple services unless one of the external requests is set to be the ",Object(i.b)("inlineCode",{parentName:"p"},"primary"),"."),Object(i.b)("p",null,"  The examples below show the expected responses when there is a primary request and when there is not."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'Primary request specified:\n\n{\n  "requests": {\n    "response": [\n      {\n        "id": "dhis",\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/encounters/1",\n          "params": {\n            "query": {\n              "id": {\n                "path": "payload.id",\n                "prefix": "",\n                "postfix": ""\n              }\n            }\n          }\n        }\n      },\n      {\n        "id": "redcap",\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/encounters/1",\n          "params": {\n            "query": {\n              "id": {\n                "path": "payload.id",\n                "prefix": "",\n                "postfix": ""\n              }\n            }\n          },\n          "primary": false\n        }\n      }\n    ]\n  }\n}\n')),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"Expected response:\n\n{\n  body: {\n    dhis: 'Response from dhis',\n    redcap: 'Response from redcap'\n  }\n}\n")),Object(i.b)("p",null,"  If one request has the property primary set to true or when there is only one request, the expected response is what is shown below"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"{\n  body: 'Response body'\n}\n"))),Object(i.b)(b,{value:"query",mdxType:"TabItems"},Object(i.b)("p",null,"  The query or URL parameters for the external requests can be populated from the incoming request's body and query object. The parameters to be added can be specified in the ",Object(i.b)("inlineCode",{parentName:"p"},"meta.json")," as shown below in config ",Object(i.b)("inlineCode",{parentName:"p"},"params")," object"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "requests": {\n    "lookup": [\n      {\n        "id": "iscec",\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/encounters/:encounterId",\n          "params": {\n            "query": {\n              "id": {\n                "path": "payload.id",\n                "prefix": "prefix",\n                "postfix": "postfix"\n              }\n            },\n            "url": {\n              "encounterId": {\n                "path": "payload.encounterId"\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n')),Object(i.b)("p",null,"  The ",Object(i.b)("inlineCode",{parentName:"p"},"id")," is the name of the query parameter. The ",Object(i.b)("inlineCode",{parentName:"p"},"path")," is the location of the value of the parameter in the incoming request body or query object. For values retrieved from the request body the ",Object(i.b)("inlineCode",{parentName:"p"},"path")," is specified by prefixing the path with the key word ",Object(i.b)("inlineCode",{parentName:"p"},"payload")," and for retrieving from the query the keyword is ",Object(i.b)("inlineCode",{parentName:"p"},"query"),". Below are examples of paths"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "config": {\n    "params": {\n      "query": {\n        "id": {\n          "path": "payload.ids[0].nationalId"\n        },\n        "name": {\n          "path": "query.name"\n        }\n      }\n    }\n  }\n}\n')),Object(i.b)("p",null,"  The properties ",Object(i.b)("inlineCode",{parentName:"p"},"postfix")," and ",Object(i.b)("inlineCode",{parentName:"p"},"prefix")," are optional. An example use case is given below"),Object(i.b)("p",null,"  For a query parameter that has the following format ",Object(i.b)("inlineCode",{parentName:"p"},"code:<Facility code>:section:52"),", if we are retrieving the ",Object(i.b)("inlineCode",{parentName:"p"},"Facility code")," from the payload or query we can specify this as shown below"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "params": {\n    "query": {\n      "filter": {\n        "path": "payload.facility_code",\n        "prefix": "code:",\n        "postfix": ":section:52"\n      }\n    }\n  }\n}\n')),Object(i.b)("p",null,"  If say the facility code in the payload is ",Object(i.b)("strong",{parentName:"p"},"1223"),", the specification above will enable us to have a query parameter - ",Object(i.b)("strong",{parentName:"p"},"?filter=code:1223:section:52")),Object(i.b)("p",null,"  For URL parameter the name of the parameter must be included in the url with a ",Object(i.b)("inlineCode",{parentName:"p"},":")," prefix. This parameter will be replaced in the URL at runtime with the value that you specify. For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "requests": {\n    "lookup": [\n      {\n        "id": "iscec",\n        "config": {\n          "method": "get",\n          "url": "http://localhost:3444/encounters/:encounterId",\n          "params": {\n            "url": {\n              "encounterId": {\n                "path": "payload.encounterId"\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n')),Object(i.b)("p",null,"  If the original request's payload had a ",Object(i.b)("inlineCode",{parentName:"p"},"encounterId")," property of ",Object(i.b)("inlineCode",{parentName:"p"},"2442")," then the url would become: ",Object(i.b)("inlineCode",{parentName:"p"},"http://localhost:3444/encounters/2442")))),Object(i.b)("h3",{id:"2-input-validation-schema"},"2. Input Validation Schema"),Object(i.b)("p",null,"The data to be mapped can be validated before the mapping occurs. A validation schema has to be created in the ",Object(i.b)("inlineCode",{parentName:"p"},"input-validation.json")," file. Below is a sample of a validation schema"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "type": "object",\n  "properties": {\n    "name": {"type": "string"},\n    "surname": {"type": "string", "nullable": true},\n  },\n  "required": ["name"]\n}\n')),Object(i.b)("p",null,"For more details on this check out ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/openhim-mediator-mapping/docs/validation"}),"validation")),Object(i.b)("h3",{id:"3-input-mapping-schema"},"3. Input Mapping Schema"),Object(i.b)("p",null,"The mapping schema in the ",Object(i.b)("inlineCode",{parentName:"p"},"input-mapping.json")," JSON document defines how the incoming data will be retrieved and used to build up a new object in the desired outcome."),Object(i.b)("p",null,"The root structure of this input mapping schema consists of two properties as defined below"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),'{\n  "input": { ... },\n  "constants": { ... } // optional\n}\n')),Object(i.b)("p",null,"The structure for both the properties are the same and are defined as below. Below is an example of the mapping"),Object(i.b)(p.a,{defaultValue:"input",values:[{label:"Input",value:"input"},{label:"Mapping Schema",value:"mapping"},{label:"Output",value:"output"}],mdxType:"Tabs"},Object(i.b)(s.a,{value:"input",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"{\n  requestBody: {\n    status: 'Active'\n  },\n  lookupRequests: {\n    location: 'Unknown'\n  }\n}\n"))),Object(i.b)(s.a,{value:"mapping",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-json"}),'{\n  "input": {\n    "requestBody.status": "status",\n    "lookupRequests.location": "location"\n  }\n}\n'))),Object(i.b)(s.a,{value:"output",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"{\n  status: 'Active',\n  location: 'Unknown'\n}\n")))),Object(i.b)("p",null,"For more details check out ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"./transformation"}),"transformation")),Object(i.b)("h3",{id:"4-constants"},"4. Constants"),Object(i.b)("p",null,"The constants file contains data to be used alongside the client input data. The constants file can contain values for fields required in the output data that weren't available from the original client input."),Object(i.b)("p",null,"Fields in the constants file can be referenced in the mapping schema in the ",Object(i.b)("inlineCode",{parentName:"p"},"constants")," section similar to the user input mapping."),Object(i.b)("h3",{id:"5-output"},"5. Output"),Object(i.b)("hr",null))}m.isMDXComponent=!0},107:function(e,n,t){var a;!function(){"use strict";var t={}.hasOwnProperty;function o(){for(var e=[],n=0;n<arguments.length;n++){var a=arguments[n];if(a){var r=typeof a;if("string"===r||"number"===r)e.push(a);else if(Array.isArray(a)&&a.length){var i=o.apply(null,a);i&&e.push(i)}else if("object"===r)for(var p in a)t.call(a,p)&&a[p]&&e.push(p)}}return e.join(" ")}e.exports?(o.default=o,e.exports=o):void 0===(a=function(){return o}.apply(n,[]))||(e.exports=a)}()},109:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return m}));var a=t(0),o=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=o.a.createContext({}),c=function(e){var n=o.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):p({},n,{},e)),t},u=function(e){var n=c(e.components);return o.a.createElement(l.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},d=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=a,m=u["".concat(i,".").concat(d)]||u[d]||b[d]||r;return t?o.a.createElement(m,p({ref:n},l,{components:t})):o.a.createElement(m,p({ref:n},l))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=d;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,i[1]=p;for(var l=2;l<r;l++)i[l]=t[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},119:function(e,n,t){"use strict";var a=t(0),o=t.n(a),r=t(107),i=t.n(r),p=t(88),s=t.n(p);const l=37,c=39;n.a=function(e){const{block:n,children:t,defaultValue:r,values:p}=e,[u,b]=Object(a.useState)(r),d=[];return o.a.createElement("div",null,o.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:i()("tabs",{"tabs--block":n})},p.map(({value:e,label:n})=>o.a.createElement("li",{role:"tab",tabIndex:"0","aria-selected":u===e,className:i()("tab-item",s.a.tabItem,{"tab-item--active":u===e}),key:e,ref:e=>d.push(e),onKeyDown:e=>((e,n,t)=>{switch(t.keyCode){case c:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case l:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(d,e.target,e),onFocus:()=>b(e),onClick:()=>b(e)},n))),o.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},a.Children.toArray(t).filter(e=>e.props.value===u)[0]))}},120:function(e,n,t){"use strict";var a=t(0),o=t.n(a);n.a=function(e){return o.a.createElement("div",null,e.children)}}}]);